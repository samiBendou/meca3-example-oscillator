# Basic concepts

Here we present the ideas to have in mind when using meca3 module. 

### Conventions

In all the code and documentation assume that :
- `u`, `v`, `w` will always name a `Vector3`
- `m` will always name a `Matrix3`
- `i` will always name a row index
- `j` will always name a column index
- `s` will always name a real number

### Object oriented syntax

The module has an object-oriented syntax. Each class provides instance methods to perform _operations_ and 
static methods as _generators_ of instances.

**Example**
```js
    let u = Vector3.ex; // Creates a new Vector3 : (1 0 0)
    console.log(u.toString()); // prints (1 0 0)
```

### Object specification

#### copy of instance
Each class provides a `.copy()` instance method that returns a `new` instance of the initial object.

#### equality
Each class provides a method named `.isEqual()` that compares two objects of the same class and return `true` when the two objects are equal in a _mathematical meaning_.

#### string interface
The method `.toString()` returns a short string representing the object. The output is _more concise_ than the output when directly printing the object.

### Operations chaining

The object oriented structure allows to perform operations chaining.

**Example**
```js
    let u = v.copy().add(w); // Creates a new Vector3 : u = v + w
    v.add(w); // Adds w into v : v = v + w
```
**Note :**  The first line does not change `v` or `w`.

Some methods perform operations between object and return an object of the same type as the calling object.
Theses methods store the result in `this` and return a reference to `this`. 
You have manage copy manually in order to avoid to modify your instances intentionally.

### Function property

The framework uses a lot of properties that are not stored in memory but that can be get and set as regular properties.

**Example**
```js
u = new Vector3.ex; // v = (1 0 0)
u.r = 2; // u = (2 0 0)
```

Theses properties are documented in as regular property. If nothing is specified, the property can be set and get.

# 3D space representation

The 3D space in this module can be represented in two ways, as a _vector space_ and as an _affine space_.
- As a vector space, a point is identified with coordinates of a `Vector3` in a basis
- As an affine space, a point is identified with a `PointPair` including the origin of the point

## Vector space

### Components
`Vector3` class uses by default cartesian coordinates to represent a vector.

**Example**
```js
    let u = Vector3.ex; // u = (1 0 0)
    u.y = 2; // u = (1 2 0)
```
`Matrix3` class also uses cartesian coordinates as components.

**Example**
```js
    let m = Matrix3.eye; // m = identity matrix
    console.log(m.x.x); // prints 1
    console.log(m.x.y); // prints 0
    console.log(m.z.z); // prints 1
```

Operations can be performed between `Matrix3` and `Vector3`.

**Example**
```js
let m = Matrix3.ones; // m = matrix filled with ones
let u = Vector3.ey; // u = (0 1 0)
console.log(m.map(u).toString()) // prints (1 1 1)
```

### Coordinates modes

The `Vector3` can be represented in commons different coordinates modes such as cylindrical and spherical.

**Example**
```js
let u = Vector3.ones; // u = (1 1 1)
console.log(u.r); // outputs +sqrt(3)
console.log(u.theta); // outputs +pi/4
```

## Affine space

### Representing a point

The `PointPair` is a pair of `Vector3` objects representing the origin's and point's vectors. 

**Example**
```js
let om = new PointPair(Vector3.zeros, Vector3.ez); // point (0 0 1) from origin (0 0 0)
console.log(om.toString()); // prints the coordinates of the point and it's origin
```

### Geometrical operations

Perform geometrical operations on the segment joining the origin and the point

**Example**
```js
let om = PointPair.vect(Vector3.ey); // point (0 1 0) from origin (0 0 0)
om.translate(Vector3.ex) // point (1 1 0) from origin (1 0 0)
```

## Matrix algebra

### Algebraical operations

You can use `Matrix3` to perform algebraical operations on matrix.

**Example**
```js
let m = Matrix3.ones; // m = matrix filled with ones
console.log(m.prod(m).toString()); // prints a matrix filled with 3
```

### Inversion

Invert matrix and get determinant with constant time lightweight algorithms.

**Example**
```js
let m = Matrix3.scal(7); // m = diagonal matrix filled with 7
console.log(m.inv.toString()); // diagonal matrix filled with 1/7
console.log(Matrix3.ones); // prints 0
```

# Trajectory and solving

## Trajectory

`Trajectory` class describes the successive positions of a point in affine space.

The class has the particularity that it also include the time step elapsed between each successive position.

### Discrete representation

The trajectory is represented in memory as an array of successive positions.

Get position the position of the point and duration at any given integer index `i`.

**Example**
```js
let ex = Vector3.ex, ey = Vector3.ey, ez = Vector3.ez; // Vectors representing trajectory
let trajectory = Trajectory.discrete([ex, ey, ez]); // trajectory with fixed origin (0 0 0) and step 1
console.log(trajectory.get(1)); // prints ey
console.log(trajectory.duration(1)); // prints 1
```

### Continuous representation

The discrete representation of the trajectory can be linearly interpolated to produced a continuous representation.

Get position the position of the point and duration at any given curvilinear abscissa `s`.

**Example**
```js
let ex = Vector3.ex, ey = Vector3.ey, ez = Vector3.ez; // Vectors representing trajectory
let trajectory = Trajectory.discrete([ex, ey, ez]); // trajectory with fixed origin (0 0 0) and step 1
console.log(trajectory.at(0.5)); // prints (ex + ey) / 2
console.log(trajectory.t(0.5)); // prints 0.5
```

**Note**: The curvilinear abscissa varies between `0` and the size of the trajectory.

### Buffer trajectory

The class `BufferTrajectory` represents a fixed size trajectory that can be updated.
It's useful especially when animating trajectory with a renderer to limit the size of the trajectory.

The `BufferTrajectory` is constructed from a `Trajectory` object but keep it _size fixed_ by truncating or adding padding.

**Example**
```js
let ex = Vector3.ex, ey = Vector3.ey, ez = Vector3.ez; // Vectors representing trajectory
let trajectory = new BufferTrajectory(2, Trajectory.discrete([ex, ey, ez])); // Truncated trajectory [ey, ez]
trajectory.add(PointPair.vect(ez)); // trajectory = [ez, ez]
```

### Variable steps

A trajectory can have a variable step between positions.

**Example**
```js
let ex = Vector3.ex, ey = Vector3.ey, ez = Vector3.ez; // Vectors representing trajectory
let trajectory = Trajectory.discrete([ex, ey, ez], [0.5, 1]);
console.log(trajectory.t(0.5)); // prints 0.25
console.log(trajectory.t(1.5)); // prints 1.0
```

## Solve

The solver provides a ODE solving for the equation in the form **d2u/dt2 = f(u, t)** where **u** is a 3D vector and
**f(u, t)** a smooth time dependent function.

The solver uses constant step Euler's explicit method to determine approximated solutions.

### General architecture

The solver integrates the function **f** as a member. You have to specify it at the construction of a `Solver`.

**Example**
```js

// Oscillating field d2u/dt2 = -u
let field = function(u) {
    return u.copy().opp;
}

let solver = new Solver(field, 0.5); // solver for field with step 0.5
```

### Step by step

The `Solver` class allows to determine solutions step by step.

**Example**
```js
let u0 = Vector3.ex;
let u1 = Vector3.ex.mul(2);
console.log(solver.step(u1, u0)); // prints u2
```

### Global solving

The `Solver` class allows to perform a given number of steps.

**Example**
```js
let u0 = Vector3.ex;
let v0 = Vector3.zeros;
console.log(solver.solve(u0, v0, 5)); // prints [u0, u1, u2, u3, u4]
```